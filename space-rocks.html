<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Interacción en WebGL</title>
  <style type="text/css">

canvas { border: 1px solid #faa; }

  </style>
</head>
<body>
  <h1>Interacción en WebGL</h1>
  <canvas id="lienzo" width="1200" height="800"></canvas>
<script id="2d-vertex-shader" type="notjs">
 
  // an attribute will receive data from a buffer
  attribute vec2 a_position;
  attribute vec4 a_color;

  uniform vec2 u_resolution;
  uniform float u_escala;
  uniform float u_rotacion;
  uniform vec2 u_translation;

  varying vec4 v_color;
 
  // all shaders have a main function
  void main() {


    vec2 posicionRotada = vec2 (a_position.y * sin(u_rotacion) - a_position.x * cos(u_rotacion),
    a_position.x * sin(u_rotacion) + a_position.y * cos(u_rotacion));

    vec2 position = posicionRotada + u_translation;

    // convert the position from pixels to 0.0 to 1.0
    vec2 zeroToOne = position / ( u_resolution * u_escala );
 
    // convert from 0->1 to 0->2
    // vec2 zeroToTwo = zeroToOne * 2.0;
 
    // convert from 0->2 to -1->+1 (clip space)
    // vec2 clipSpace = zeroToTwo - 1.0;
 
    // gl_Position = vec4(clipSpace, 0, 1);
    gl_Position = vec4(zeroToOne, 0, 1);

    v_color = a_color;
    gl_PointSize = 4.0;
  }
 
</script>
 
<script id="2d-fragment-shader" type="notjs">
 
  // fragment shaders don't have a default precision so we need
  // to pick one. mediump is a good default
  precision mediump float;

  // uniform vec4 u_color;

  varying vec4 v_color;

  void main() {
    // gl_FragColor is a special variable a fragment shader
    // is responsible for setting
    gl_FragColor = v_color;

  }
</script>

<script type="text/javascript">


function createShader(gl, type, source) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }
 
  console.log(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
}

function createProgram(gl, vertexShader, fragmentShader) {
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  var success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }
 
  console.log(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
}


function Escenario(gl){
  this.gl = gl;
  this.sprites = [];

  var vertexShaderSource = document.getElementById("2d-vertex-shader").text;
  var fragmentShaderSource = document.getElementById("2d-fragment-shader").text;
  
  var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  var program = createProgram(gl, vertexShader, fragmentShader);
  this.program = program;

  // attribute Locations
  this.positionAttributeLocation = gl.getAttribLocation(program, "a_position");
  this.colorLocation = gl.getAttribLocation(program, "a_color");

  // Uniform locations
  this.resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
  this.escalaUniformLocation = gl.getUniformLocation(program, "u_escala");
  this.rotacionUniformLocation = gl.getUniformLocation(program, "u_rotacion");
  // var colorUniformLocation = gl.getUniformLocation(program, "u_color");
  this.translationLocation = gl.getUniformLocation(program, "u_translation");

  this.resolution = [1, 1];
  this.zoom = 12;
  this.t = 0;

  if ( gl.canvas.width >  gl.canvas.height ){
    this.resolution[0] =  gl.canvas.width /  gl.canvas.height;
  } else {
    this.resolution[1] = gl.canvas.height / gl.canvas.width;
  }
}
Escenario.prototype = {
  addSprite: function (sprite){
    this.sprites.push(sprite);
  },
  removeSprite: function (sprite){
    var i  = this.sprites.indexOf(sprite);
    if (i > -1){
      this.sprites.splice(i, 1);
    }
  },
  draw: function (tiempo){
    this.gl.useProgram(this.program);

    // set the resolution
    this.gl.uniform2f(this.resolutionUniformLocation, this.resolution[0], this.resolution[1]);
    this.gl.uniform1f(this.escalaUniformLocation, this.zoom);

    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    // Clear the canvas
    // var b = this.t / 100;
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Iterar en todos los sprites registrados, llamar Sprite.draw()
    this.sprites.forEach(function(item, index){
      item.draw();
    });

    // console.log(this);
    var e = this;
    setTimeout(function(){
      e.frame();
    }, 30);
    return;
  },
  frame: function (){
    this.t ++;
    var e = this;
    // console.log(this);
    // console.log(this.draw);

    // Iterar en todos los sprites registrados, llamar Sprite.frame()
    this.sprites.forEach(function(item, index){
      item.frame();
    });

    requestAnimationFrame(function(tiempo){
      e.draw(tiempo);
    });
    return;
  }
};

function Sprite(){
}
Sprite.prototype = {
  firstPoint: function(){
    return 0;
  },
  pointsCount: function(){
    return 0;
  },
  primitive: function(){
    return this.escenario.gl.TRIANGLES;
  },
  inicializa: function(escenario){
    this.translacion = [0, 0]
    this.rotacion = 0;

    this.escenario = escenario;
    escenario.addSprite(this);
    this.positionBuffer = escenario.gl.createBuffer();
    this.colorBuffer = escenario.gl.createBuffer();

    escenario.gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    this.setGeometry();
    escenario.gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    this.setColors();

  },
  setTranslacion: function(translacion){
    this.translacion = translacion;
  },
  setRotacion: function(rotacion){
    this.rotacion = rotacion;
  },
  setGeometry: function(){},
  setColors: function(){},
  draw: function(){
    var gl = this.escenario.gl;
    gl.enableVertexAttribArray(this.escenario.positionAttributeLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    var size = 2;          // 2 components per iteration
    var type = gl.FLOAT;   // the data is 32bit floats
    var normalize = false; // don't normalize the data
    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0;        // start at the beginning of the buffer
    gl.vertexAttribPointer(
        this.escenario.positionAttributeLocation, size, type, normalize, stride, offset);
    gl.enableVertexAttribArray(this.escenario.colorLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    var size = 4;          // 2 components per iteration
    var type = gl.FLOAT;   // the data is 32bit floats
    var normalize = false; // don't normalize the data
    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0;        // start at the beginning of the buffer
    gl.vertexAttribPointer(
        this.escenario.colorLocation, size, type, normalize, stride, offset);
    gl.uniform2fv(this.escenario.translationLocation, this.translacion);
    gl.uniform1f(this.escenario.rotacionUniformLocation, this.rotacion);
    gl.drawArrays(this.primitive(), this.firstPoint(), this.pointsCount());  // La cantidad de puntos a procesar depende de la clase en particular
  },
  frame: function(){
    this.subframe();
    var e = this.escenario;

    if (this.translacion[0] > e.zoom * e.resolution[0]){
      this.translacion[0] = e.zoom * e.resolution[0] * -1;
    } else if (this.translacion[0] < e.zoom * e.resolution[0] * -1){
      this.translacion[0] = e.zoom * e.resolution[0];
    }
    if (this.translacion[1] > e.zoom * e.resolution[1]){
      this.translacion[1] = e.zoom * e.resolution[1] * -1;
    } else if (this.translacion[1] < e.zoom * e.resolution[1] * -1){
      this.translacion[1] = e.zoom * e.resolution[1];
    }
  },
  subframe: function(){}
};

function Nave(){}
Nave.prototype = new Sprite();
Nave.prototype.inicializa = function(escenario){
  Sprite.prototype.inicializa.call(this, escenario);

  this.velocidadRota = 4;
  this.velocidadAvanza = [0, 0];
  this.aceleraAvanza = 1;
  //this.pointsCount = 6;

  // TODO: Mover estos a su propia función u objeto de contol por teclado (o joystick)
  this.kmas = false;
  this.kmenos = false;
  this.kleft = false;
  this.kright = false;
  this.kup = false;
  // this.space = false;

  s = this;
  // Manejador de teclado
  window.addEventListener("keydown", function(e){
    // console.log(e);
    switch(e.key){
      case '+':
        s.kmas = true;
        break;
      case '-':
        s.kmenos = true;
        break;
      case 'ArrowLeft':
        s.kleft = true;
        break;
      case 'ArrowRight':
        s.kright = true;
        break;
      case 'ArrowUp':
        s.kup = true;
        break;
      case ' ':
        s.dispara();
        break;
    }
  });

  window.addEventListener("keyup", function(e){
    switch(e.key){
      case '+':
        s.kmas = false;
        break;
      case '-':
        s.kmenos = false;
        break;
      case 'ArrowLeft':
        s.kleft = false;
        break;
      case 'ArrowRight':
        s.kright = false;
        break;
      case 'ArrowUp':
        s.kup = false;
        break;
    }
  });
}
Nave.prototype.setGeometry = function(){
  var gl = this.escenario.gl;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0, 1,
    0.75, -1,
    0, -0.5,
    0, -0.5,
    -0.75, -1,
    0, 1
  ]), gl.STATIC_DRAW);
};
Nave.prototype.setColors = function(){
  var gl = this.escenario.gl;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0.75, 1, 0.8, 1,
    0.2, 0.5, 0.75, 1,
    0.2, 1, 0.8, 1,
    0.25, 0.75, 0.8, 1,
    0.5, 0.75, 0.9, 1,
    0.5, 0.65, 0.75, 1
  ]), gl.STATIC_DRAW);
};
Nave.prototype.pointsCount = function(){
  return 6;
}
Nave.prototype.subframe = function(){
  const deltaTime = 0.03;
  var e = this.escenario;

  if (this.kmas){
    this.zoom += deltaTime * this.velocidadZoom;
  }
  if (this.kmenos){
    this.zoom -= deltaTime * this.velocidadZoom;
  }
  if (this.kleft){
    this.rotacion -= deltaTime * this.velocidadRota;
  }
  if (this.kright){
    this.rotacion += deltaTime * this.velocidadRota;
  }
  if (this.kup){
    // rotacion += deltaTime * velocidadRota;
    this.velocidadAvanza[0] += deltaTime * this.aceleraAvanza * Math.sin(this.rotacion);
    this.velocidadAvanza[1] += deltaTime * this.aceleraAvanza * Math.cos(this.rotacion);
  } else {
    if (this.velocidadAvanza[0] > 0) {
      this.velocidadAvanza[0] -= deltaTime * this.aceleraAvanza * 0.25;
    } else if  (this.velocidadAvanza[0] < 0) {
      this.velocidadAvanza[0] += deltaTime * this.aceleraAvanza * 0.25;
    }
    if (this.velocidadAvanza[1] > 0) {
      this.velocidadAvanza[1] -= deltaTime * this.aceleraAvanza * 0.25;
    } else if  (this.velocidadAvanza[1] < 0) {
      this.velocidadAvanza[1] += deltaTime * this.aceleraAvanza * 0.25;
    }
  }
  this.translacion[0] += this.velocidadAvanza[0];
  this.translacion[1] += this.velocidadAvanza[1];

  /*
  if ((this.velocidadAvanza[0] > 0) && (this.translacion[0] > (e.zoom * e.resolution[0]) + 1)){
    this.translacion[0] = (e.zoom * e.resolution[0] * -1) - 1;
  } 
  if ((this.velocidadAvanza[0] < 0) && (this.translacion[0] < (e.zoom * e.resolution[0] * -1) - 1)){
    this.translacion[0] = (e.zoom * e.resolution[0]) + 1;
  }
  if ((this.velocidadAvanza[1] > 0) && (this.translacion[1] > (e.zoom * e.resolution[1]) + 1)){
    this.translacion[1] = (e.zoom * e.resolution[1] * -1) - 1;
  } 
  if ((this.velocidadAvanza[1] < 0) && (this.translacion[1] < (e.zoom * e.resolution[1] * -1) - 1)){
    this.translacion[1] = (e.zoom * e.resolution[1]) + 1;
  }
  */
}
Nave.prototype.dispara = function(){
  var b = new Bala();
  var t = [this.translacion[0], this.translacion[1]];
  b.inicializa(this.escenario, t, this.rotacion);
}

function Roca(){
  //this.pointsCount = 33;
}
Roca.prototype = new Sprite;
Roca.prototype.setGeometry = function (){
  var gl = this.escenario.gl;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0, 0,
    -0.5, 0.5,
    -0.5, 1,
    0.5, 1,
    1, 0.5,
    1, 0,
    0.5, -0.5,
    0.5, -1,
    0, -1,
    -0.5, -0.5,
    -1, -0.5,
    -1, 0,
    -0.5, 0.5
  ]), gl.STATIC_DRAW);
};
Roca.prototype.setColors = function(){
  var gl = this.escenario.gl;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0.9, 0.75, 0.2, 1,
    0.9, 0.75, 0.3, 1,
    0.8, 0.8, 0.2, 1,
    0.8, 0.5, 0.2, 1,
    0.9, 0.65, 0.15, 1,
    0.9, 0.75, 0.25, 1,
    0.8, 0.75, 0.2, 1,
    0.9, 0.65, 0.2, 1,
    0.9, 0.7, 0.25, 1,
    0.95, 0.85, 0.15, 1,
    0.8, 0.6, 0.3, 1,
    0.8, 0.75, 0.4, 1,
    0.8, 0.65, 0.1, 1,
  ]), gl.STATIC_DRAW);
};
Roca.prototype.pointsCount = function(){
  return 13;
}
Roca.prototype.primitive = function(){
  return this.escenario.gl.TRIANGLE_FAN;
}
Roca.prototype.subframe = function (){
  var e = this.escenario;
  
  this.translacion[0] += this.velocidad * Math.sin(this.direccion);
  this.translacion[1] += this.velocidad * Math.cos(this.direccion);
}
Roca.prototype.inicializa = function(escenario){
  Sprite.prototype.inicializa.call(this, escenario);

  this.velocidad = 0.05;
  this.direccion = Math.random() * 2 * Math.PI;

  var w = escenario.zoom * escenario.resolution[0] * 2;
  this.translacion[0] = (w * Math.random()) - (w / 2);
  var h = escenario.zoom * escenario.resolution[1] * 2;
  this.translacion[1] = (h * Math.random()) - (h / 2);
}

function Bala(){}
Bala.prototype = new Sprite;
Bala.prototype.setGeometry = function(){
  var gl = this.escenario.gl;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0, 0
    ]), gl.STATIC_DRAW);
};
Bala.prototype.setColors = function(){
  var gl = this.escenario.gl;
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    0.75, 0.25, 0.9, 1,
  ]), gl.STATIC_DRAW);
};
Bala.prototype.pointsCount = function(){
  return 1;
};
Bala.prototype.primitive = function(){
  return this.escenario.gl.POINTS;
};
Bala.prototype.inicializa = function(escenario, translacion, direccion){
  Sprite.prototype.inicializa.call(this, escenario);

  translacion[0] += 1 * Math.sin(direccion);
  translacion[1] += 1 * Math.cos(direccion);

  this.translacion = translacion;
  this.direccion = direccion;
  this.velocidad = 0.25;
  this.duracion = escenario.zoom * 2 / this.velocidad;
  console.log(escenario);
};
Bala.prototype.subframe = function(){
  var e = this.escenario;

  this.duracion --;
  if (this.duracion <= 0){
    e.removeSprite(this);
  }
  
  this.translacion[0] += this.velocidad * Math.sin(this.direccion);
  this.translacion[1] += this.velocidad * Math.cos(this.direccion);
  
}

function inicializa(gl, elemento){
  console.log("WebGL está soportado por el navegador");
  console.log (gl);

  var e = new Escenario(gl);
  var s = new Nave();
  var r = new Roca();
  var r2 = new Roca();
  r.inicializa(e);
  s.inicializa(e);
  r2.inicializa(e);
  e.draw();

}


var canvas = document.getElementById('lienzo');

if (canvas.getContext) {

  var gl = canvas.getContext('webgl');
  if (gl){
    inicializa(gl, canvas);
  } else {
    alert("Error: Navegador no soporta WebGL");
  }

} else {

  alert("Navegador no soporta elemento canvas");

}

</script>


</body>
</html>
